import { Markdown } from '../../components/Page';
import { ComingSoon } from '../../components/ComingSoon';

# How to embed Keystone Lite within a NextJS frontend app

We recently added SQLite to our list of supported databases. üéâ &nbsp; Now you can run a local instance of Keystone from the same place you keep your frontend code and commit all your content to Git.

If you want to swap MDX for an intuitive editing UI, and don‚Äôt need to provide write access to other editors, this may be the guide for you.

---

[Keystone Lite](https://github.com/keystonejs/keystone/tree/master/examples/next-lite) is a streamlined `mode` that you can operate Keystone with. It takes advantage of SQLite‚Äòs embedded local storage capabilities to give you a powerful CMS that you can run locally and store content in the same place you keep your frontend code.

The tutorial will show you how to: 

- setup a NextJS frontend
- integrate Keystone, and run an Admin UI you can read and write to locally
- provision a secure read-only GraphQL API endpoint (and playground) you can access in production
- deploy your CMS and frontend monorepo to Vercel in minutes

!> If you need access to an Keystone‚Äôs Admin UI over the internet, or want to provide access to more than one, use Keystone in the regular `headless` mode.

Let‚Äôs get started‚Ä¶

## Setup a NextJS app

x> [RONALD] Should we offer a jump link for people who want to bypass all the NextJS setup? 

### Dependencies 

Start out by adding NextJS and its dependencies in an empty project directory:

```bash
yarn add next react react-dom
```

Keystone Next is built in TypeScript. Adding Typescript and Prettier as `--dev` dependencies will make Keystone implementation easier later on. Let‚Äòs get that out of the way now:

```bash
yarn add --dev typescript @types/react prettier
```

### Scripts

Update the `package.json` file to include the following [NextJS CLI `scripts`](https://nextjs.org/docs/api-reference/cli) and `prettier` configuration options:

```json

// package.json

{
  "dependencies": {
    "next": "^10.2.0",
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  },
  "devDependencies": {
    "@types/react": "^17.0.4",
    "prettier": "^2.2.1",
    "typescript": "^4.2.4"
  },
  "scripts": {
    "dev": "next dev",
    "start": "next start",
    "build": "next build"
  },
  "prettier": {
    "arrowParens": "avoid",
    "proseWrap": "preserve",
    "singleQuote": true,
    "trailingComma": "es5"
  }
}
```

### Version control

Add the following to your `.gitignore` to avoid committing changes to `.keystone` and `.next` build directories and a few other things:

x> [RONALD]can ‚¨áÔ∏è &nbsp; be streamlined to make learning easier?

```bash

# .gitignore

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Dependency directories
node_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Keystone.js build output
.keystone
```

### Add your first page  

1. Create a `/pages` directory at the root of your project containing an `index.tsx` with with the following:

```tsx
// pages/index.tsx

export default function Home() {
  return <h1>Hello World! üëãüèª </h1>;
}
```

!> In Next.js, a [page](https://nextjs.org/docs/basic-features/pages) is a React Component exported from a `.js`, `.jsx`, `.ts`, or `.tsx` file in the `/pages` directory. Each page is associated with a route based on its file name.

### Startup your local server

Run `yarn dev` at the root of your project. NextJS will give you a local server at [`http://localhost:3000`](http://localhost:3000) üéâ:  

![A browser showing the Home page of the new app](/assets/tutorials/next-lite/localhost-home-1.png)

### Add a blog post

Now that we have a local server up and running, let‚Äòs extend our content with a `post` type using static files in to start out. (We‚Äôll soon be powering posts with content from Keystone.) In order to get `<link>` tags to work we need to add an [`_app.tsx`](https://nextjs.org/docs/basic-features/typescript#custom-app) file inside `/pages`:

x> [RONALD] I think ‚¨áÔ∏è &nbsp; is the default app code per NextJS, but links don't work without it which is surprising to my layman's eyes. Are the _app contents necessary?

```tsx
// pages/_app.tsx

function App({ Component, pageProps }) {
  return <Component {...pageProps} />;
}

export default App;

```

Add a `/post` subdirectory and include the following in `[slug].tsx`:

```tsx

// pages/post/[slug].tsx

import Link from 'next/link';

export default function Home() {
  return (
    <div>
      <div>
        <Link href="/">
          <a>&larr; back home</a>
        </Link>
      </div>
      <h1>My first post!</h1>
      <p></p>
    </div>
  );
}
```

And update the contents of `/pages/index.tsx` with the following:

```tsx

// pages/index.tsx

import Link from 'next/link';

export default function Home() {
  return (
    <div>
      <h1>Hello World! üëãüèª </h1>
      <h2>My posts:</h2>
      <ul>
        <li>
          <Link href="/post/my-first-post">
            <a>My first post</a>
          </Link>
        </li>
      </ul>
    </div>
  );
}
```

Running `yarn dev` again will update the home page with links between it and your first post:

![A browser showing link navigation from the Home page to a single post](/assets/tutorials/next-lite/localhost-home-to-post.gif)

## Add Keystone to your project

Now that we have a scaffold with statis files, let‚Äòs integrate Keystone with NextJS to blend file-based content with dynamic posts that you can edit in Keystone‚Äôs intuitive Admin UI.

### Install dependencies

Add the following Keystone dependencies to the project:

```bash
yarn add @keystone-next/keystone @keystone-next/admin-ui @keystone-next/fields

```

### Add Keystone to NextJS config

Add a `next.config.js` file to the project root with the following:

```tsx

// next.config.js

const { withKeystone } = require('@keystone-next/keystone/next');

module.exports = withKeystone();
```

The `withKeystone` constant lets NextJS encapsulate Keystone in its script runtime, but Keystone still operates independently of the NextJS frontend.

### Add a Post type via Keystone config

Now add a `keystone.ts` file to the project root. This is where we‚Äôll setup the `Post` [list](/apis/schema) type for blog entries that can be edited in Keystone‚Äôs Admin UI:

```tsx
// keystone.ts

import { config, list } from '@keystone-next/keystone/schema';
import { text } from '@keystone-next/fields';

const Post = list({
  fields: {
    title: text({ isRequired: true }),
    slug: text(),
    content: text(),
  },
});

// [RONALD] Would annotation be helpful here?
export default config({
  db: { adapter: 'prisma_sqlite', url: 'file:./app.db' },
  experimental: {
    generateNextGraphqlAPI: true,
    generateNodeAPI: true,
  },
  lists: { Post },
});
```

### Update package scripts

Finally, make a small change to the `scripts` object in `package.json` to include Keystone‚Äòs `postinstall`:

x> [RONALD] should we display ‚¨áÔ∏è &nbsp; the entire contents of package.json?

```json
	// within package.json

  "scripts": {
    "postinstall": "keystone-next postinstall", // new
    "dev": "next dev",
    "start": "next start",
    "build": "next build"
  },
```

Running `yarn dev` again does the following:

- Provisions a GraphQL schema based on the configuration of `keystone.ts`.
- Builds a [Prisma.io](https://www.prisma.io/) schema (which Keystone uses to create tables in the database).
- Serves Keystone‚Äôs Admin UI at [`http://localhost:8000`](http://localhost:8000) (in addition to the NextJS frontend at port 3000).
- Adds a `postinstall` script that ensures when we install dependencies everything is OK.

![Local server instances of the NExtJS frontend, and Keystone Admin UI](/assets/tutorials/next-lite/localhost-next-keystone.gif)

## Create a relationship in Keystone

Let‚Äôs extend the Keystone content model to include authors, and relate them to posts. We‚Äôll make a separate `schema.ts` file to handle lists and import them into the `keystone.ts` configuration:

```ts
// schema.ts

import { list } from '@keystone-next/keystone/schema';
import { relationship, text } from '@keystone-next/fields';

// generates a slug from title fields
// and converts the value to lower case
function slug() {
  return text({
    defaultValue: ({ originalInput }: any) => {
      const input = originalInput?.name || originalInput?.title || 'new-item';
      return (
        input
          .trim()
          .toLowerCase()
          .replace(/[^\w ]+/g, '')
          .replace(/ +/g, '-') ?? ''
      );
    },
    ui: { createView: { fieldMode: 'hidden' } },
  });
}

export const Post = list({
  fields: {
    title: text({ isRequired: true }),
    slug: slug(),
    description: text(),
    author: relationship({ ref: 'Author.posts' }),
  },
});

export const Author = list({
  fields: {
    name: text(),
    slug: slug(),
    posts: relationship({ ref: 'Post.author', many: true }),
  },
});
```

```ts
// keystone.ts

import { config } from '@keystone-next/keystone/schema';

// gets all lists configured in schema.ts
import * as lists from './schema';

export default config({
  db: { adapter: 'prisma_sqlite', url: 'file:./app.db' },
  experimental: {
    generateNextGraphqlAPI: true,
    generateNodeAPI: true,
  },
  lists,
});
```

## Query Keystone content from the frontend

In order to query Keystone content we need to add Next‚Äôs [`getStaticProps`](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation) and [`getStaticPaths`](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation) functions to the following files:

```tsx
// pages/index.tsx

import Link from 'next/link';

// get `lists` from Keystone
import { lists } from '.keystone/api';

export default function Home({ posts }) {
  return (
    <div>
      <h1>Hello World! üëãüèª </h1>
      <h2>My posts:</h2>
      <ul>
		// map over existing posts and output their title as list items
        {posts.map(post => (
          <li key={post.id}>
              <Link href={`/post/${post.slug}`}>
                <a>{post.title}</a>
              </Link>
          </li>
        ))}
      </ul>
    </div>
  );
}

export async function getStaticProps() {
  const posts = await lists.Post.findMany({ query: 'id title slug' });
  return { props: { posts } };
}
```

```tsx
// pages/post/[slug].tsx

import Link from 'next/link';

import { lists } from '.keystone/api';

export default function Home({ post }) {
  return (
    <div>
      <div>
        <Link href="/">
          <a>&larr; back home</a>
        </Link>
      </div>
      <h1>{post.title}</h1>
			// get the author name if one exists
      {post.author && <p>by {post.author.name}</p>}
      <p>{post.description}</p>
    </div>
  );
}

export async function getStaticPaths() {
  const posts = await lists.Post.findMany({
    query: `slug`,
  });

  const paths = posts
    .map(post => post.slug)
    .filter((slug): slug is string => !!slug)
    .map(slug => `/post/${slug}`);

  return {
    paths,
    fallback: false,
  };
}

export async function getStaticProps({ params: { slug } }) {
  const [post] = await lists.Post.findMany({
    where: { slug },
    query: 'id title description author { name }',
  });
  return { props: { post } };
}
```
x> [RONALD] I haven't included the step from Jed‚Äôs presentation >>> Add the document field and associated rendering code. It feels extraneous to the primary learning objective.

## Add the GraphQL API to the frontend

To get a read-only GraphQL API and playground in production, we add a single `graphql.tsx` file to the pages directory:

```tsx
// pages/api/graphql.tsx

export { default, config } from '.keystone/next/graphql-api';
```
This takes the fully functional GraphQL API that Keystone is already generating and makes it available as queryable an endpoint and playground within the NextJS frontend app at: `[http://localhost:3000/api/graphql](http://localhost:3000/api/graphql)`.

![A browser displaying the GraphQL playground](/assets/tutorials/next-lite/graphql-api.png)

This gives us the ability to implement a search against the same content API you have running at build time, in run time.

## Deploy to Vercel

Optional: 

To get your project on the internet via Vercel hosting complete he following steps:

1. Commit your project to a repository in Github, Gitlab, or Bitbucket.
2. Login to Vercel using an account from the services above.
3. Create a new Vercel project and link it to your newly created repository.

![A browser displaying the GraphQL playground](/assets/tutorials/next-lite/vercel-new-project.gif)

## Summary

Keystone‚Äôs introduction of SQLite gives you the option to run a self contained CMS from the same place you keep your frontend code. While this option restricts read-write access to people who can run the project in local development, it has advantages with ease of setup, security, and web deployment. Keystone Lite is also a great way to deploy a read-only API on the web for content you manage on your computer.

export default ({ children }) => <Markdown>{children}</Markdown>;
